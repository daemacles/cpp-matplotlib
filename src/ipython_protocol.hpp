#pragma once

#include <cstdio>
#include <cstring>
#include <unistd.h>
extern "C" {
#include <uuid/uuid.h>
}

#include <functional>
#include <iomanip>
#include <sstream>
#include <string>

#include <jsoncpp/json/json.h>
#include <openssl/engine.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <zmq.hpp>

struct IPyKernelConfig; // forward def

/// Function object that computes an HMAC hash from a vector of JSON values.
typedef std::function<std::string(std::vector<Json::Value>)> HmacFn;

/// The different kinds of socket ports that an iPython kernel listens on.
enum class PortType {SHELL, IOPUB, STDIN, HB};

//--------------------------------------------------
/** \brief Generates a new UUID
 */
std::string GetUuid(void);


//--------------------------------------------------
/** \brief Returns a string URI like "tcp://hostname:port" from its args.
 *
 * \param config  Config containing hostname and transport type.
 * \param port  Port the host is listening on.
 */
std::string BuildUri(const IPyKernelConfig &config, PortType port);


//======================================================================
/** \brief Configuration values for connecting to an iPython kernel.  See
 * http://ipython.org/ipython-doc/1/development/messaging.html for more
 * details.
 */
struct IPyKernelConfig {
  /// The port the shell socket is listening on 
  size_t shell_port;

  /// The port the iopub socket is listening on 
  size_t iopub_port;

  /// The port the stdin socket is listening on 
  size_t stdin_port;
  
  /// The port the shell is listening on 
  size_t hb_port;

  /// The IP address the kernel is listening on 
  std::string ip;

  /// The transport used by the kernel, e.g., "tcp"
  std::string transport;

  /// \brief The hash function used to generate HMACs.  Only sha-256 is
  /// supported at this time.
  std::string signature_scheme;

  /// The key used for HMAC generation
  std::string key;

  //--------------------------------------------------
  /** \brief Constructs a new IPyKernelConfig from a JSON file on disk, such
   * as the one generated by \code ipython kernel --pylab \endcode.
   */
  IPyKernelConfig (const std::string &jsonConfigFile);
}; 


//======================================================================
/** \brief Struct that wraps up the different data (i.e. not metadata like
 * HMAC) fields for an IPython ZMQ General Message Format.  See
 * http://ipython.org/ipython-doc/1/development/messaging.html#general-message-format
 * for more detail.
 */
struct IPythonMessage {
  /// The header = {'msg_id', 'username', 'session', 'msg_type'}
  Json::Value header;

  /// The header of this message's parent.  To associate response with request
  Json::Value parent;

  /// Metadata for this message.  Seems to be unused?
  Json::Value metadata;

  /// Content payload for this message.  msg_type dependant.
  Json::Value content;

  //--------------------------------------------------
  /** \brief Constructs an empty message for a specific session.
   *
   * \param ident  identity of the session this message belongs to.
   */
  explicit IPythonMessage(const std::string &ident) 
    : header{Json::objectValue},
    parent{Json::objectValue},
    metadata{Json::objectValue},
    content{Json::objectValue}
  {
    char username[80];
    getlogin_r(username, 80);
    header["username"] = std::string(username);
    header["session"] = ident;
    header["msg_id"] = GetUuid();
  }

  //--------------------------------------------------
  /** \brief Constructs a message with predefined fields.
   *
   * \param message_parts  A vector of JSON objects to assign to each of the
   *                       fields.  It assumes the elements will be in order
   *                       [header, parent_header, metadata, content].
   */
  explicit IPythonMessage(const std::vector<Json::Value> &message_parts)
    : header(message_parts[0]),
    parent(message_parts[1]),
    metadata(message_parts[2]),
    content(message_parts[3])
  {}

  std::vector<Json::Value> GetMessageParts(void) const;
};


//======================================================================
/** \brief Class of factory methods for constructing various kinds of
 * IPythonMessages associated with a particular session.
 *
 * Usage:
\code
    MessageBuilder builder("my_session_id");
    IPythonMessage command = builder.BuildExecuteRequest("print 'Hello!'");
\endcode
 */
class MessageBuilder {
public:
  //--------------------------------------------------
  /** \brief Constructs a new MessageBuilder associated with a specific
   * session.
   *
   * \param ident  the identity of the session, any arbitrary string, but .
   */
  explicit MessageBuilder(const std::string &ident) : ident_(ident) {}

  //--------------------------------------------------
  /** \brief Returns a new ExecuteRequest message.
   *
   * \param code  The code to be run in an iPython kernel.
   */
  IPythonMessage BuildExecuteRequest (const std::string &code) const ;

private:
  const std::string ident_;
};


//======================================================================
/** \brief A connection to the shell socket of an iPython kernel.
 *
 * TODO fill this out!
 */
class ShellConnection {
public:
  // 
  ShellConnection(const IPyKernelConfig &config, zmq::context_t &context,
                  const HmacFn &hmac_fn)
    : hmac_fn_{hmac_fn},
    ident_{GetUuid()},
    message_builder_{ident_},
    socket_(context, ZMQ_DEALER),
    uri_{BuildUri(config, PortType::SHELL)}
  {}

  void Connect(void);
  IPythonMessage Send(const IPythonMessage &message);
  void RunCode (const std::string &code);
  bool HasVariable (const std::string &variable_name);

private:
  const HmacFn hmac_fn_;
  const std::string ident_;
  const MessageBuilder message_builder_;
  zmq::socket_t socket_; 
  const std::string uri_;
};


class IPythonSession {
public:
  explicit IPythonSession (const IPyKernelConfig &config)
    : config_{config},
    zmq_context_{1},
    hmac_fn_{std::bind(&IPythonSession::ComputeHMAC_, this, 
                       std::placeholders::_1)},
    shell_connection_{config, zmq_context_, hmac_fn_}
  {}

  void Connect (void);
  ShellConnection& Shell (void) { return shell_connection_; }

private:
  std::string ComputeHMAC_(const std::vector<Json::Value> &parts) const;

  const IPyKernelConfig config_;
  zmq::context_t zmq_context_;
  HmacFn hmac_fn_;
  ShellConnection shell_connection_;  
};
